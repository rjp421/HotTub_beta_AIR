/*
BongTVLive.com Hot Tub 2.0 beta6 by b0nghitter
*/
//trace("|###| AdminManager |###|>  Loading...");


load("TestBot.asc");


function AdminManager()
{
	trace("|###| AdminManager |###|>  Loaded!");
	
	//disallow debug connections
	this.allowDebug = false;
	//verbose debug output
	this.verboseDebug = true;
	//shutdown timer count
	this.shutdownTimerCount = 0;
	//seconds until shutdown
	this.shutdownWaitTimeSeconds = 0;
	
	//TEST
	this.testBots_Arr = new Array();
	this.bots = new Object();
	
	//an array to keep track of banned users
	this.bannedUsersSO = SharedObject.get("bannedUsers", true);
	this.bannedUsers = this.bannedUsersSO.getProperty("bannedUsers");
	
	if (this.bannedUsers == null || this.bannedUsers == undefined)
	{
		this.bannedUsers = new Object();
		this.bannedUsersSO.setProperty("bannedUsers", this.bannedUsers);
		this.bannedUsersSO.flush();
	}
	
	//an array to keep track of users ignores
	this.userIgnoresSO = SharedObject.get("userIgnores", true);
	this.userIgnores = this.userIgnoresSO.getProperty("userIgnores");
	
	if (this.userIgnores == null || this.userIgnores == undefined)
	{
		this.userIgnores = new Object();
		this.userIgnoresSO.setProperty("userIgnores", this.userIgnores);
		this.userIgnoresSO.flush();
	}
	
	this.guestAccessSO = SharedObject.get("guestAccess", true);
	if (!this.guestAccessSO.getProperty("guestAccess"))
	{
		this.guestAccessSO.setProperty("guestAccess", true);
	}
	
	// ONLY RUN ONCE, DELETE AFTER SUCCESS
	//this.fixBlocks();
}


// TODO:
// switch to use clientID instead of the globally available
// userID.
AdminManager.prototype.adminCmd = function(msgObj)
{
	var adminObj = (msgObj.clientID ? application.userManager.getClientFromClientID(msgObj.clientID) : application.userManager.users["user_" + msgObj.userID]);
		
	// anti-spoof
	if (!adminObj) return;
	
	trace("|###| AdminManager.adminCmd |###|>  clientID: "+msgObj.clientID+"  userID: "+msgObj.userID+"  selectedUserID: "+msgObj.selectedUserID+"  adminObj: "+adminObj+"  adminType: "+adminObj.adminType);
	
	var selectedUserObj = (msgObj.selectedUserID == undefined ? adminObj : application.userManager.users["user_"+msgObj.selectedUserID]);
	
	trace("|###| AdminManager.adminCmd |###|>  adminID: "+adminObj.userID+"  selectedUserID: "+msgObj.selectedUserID+"  msg: "+msgObj.msg);
	
	if (!selectedUserObj)
	{
		selectedUserObj = new Object();
		selectedUserObj.userID = adminObj.userID;
	}
	
	if (msgObj.cmd)
	{
		msgObj.msg = msgObj.cmd;
		var msgArr = msgObj.msg.split(" ");
		var indexOfFirstSpace = msgObj.msg.indexOf(" ") + 1;
	} else {
		// get rid of the leading / from the msg
		msgObj.msg = msgObj.msg.substr(1, msgObj.msg.length);
		var msgArr = msgObj.msg.split(" ");
		var indexOfFirstSpace = msgObj.msg.indexOf(" ") + 1;
		msgObj.reason = msgObj.msg.slice(indexOfFirstSpace, msgObj.msg.length);
	}
	
	if (msgObj.reason=="kick" || 
		msgObj.reason=="ban" || 
		msgObj.reason=="banip" || 
		msgObj.reason=="gag" || 
		msgObj.reason=="undefined" || 
		msgObj.reason==undefined || 
		msgObj.reason=="")
	{
		msgObj.reason= "No reason given";
	}
	
	switch (msgArr[0].toLowerCase())
	{
		case "shutdown":
			if ((adminObj.adminType=="sa" || 
				adminObj.adminType=="ga" || 
				adminObj.adminType=="rh"))
			{
				var splitReason_Arr = msgObj.reason.split(" ", 1);
				var shutdownWaitTimeSeconds = splitReason_Arr[0];
				var shutdownWarningMsg = splitReason_Arr[1];
				
				if (shutdownWaitTimeSeconds > 0)
				{
					this.shutdownWaitTimeSeconds = shutdownWaitTimeSeconds;
				} else {
					shutdownWaitTimeSeconds = 31;
					this.shutdownWaitTimeSeconds = shutdownWaitTimeSeconds;
				}
				
				trace("|###| AdminManager.adminCmd |###|>  <shutdown>  userName: "+adminObj.userName+"  shutdownWaitTimeSeconds: "+this.shutdownWaitTimeSeconds+"  shutdownWarningMsg: "+shutdownWarningMsg);
				
				this.timerInterval = setInterval(shutdownAppTimerFunction, 1000, adminObj.userName, true, shutdownWarningMsg);
				
				shutdownWaitTimeSeconds = null;
				shutdownWarningMsg = null;
				splitReason_Arr = null;
			}
		break;
		case "setmod":
			if ((selectedUserObj)&&
				(adminObj.adminType=="sa"||
				adminObj.adminType=="ga"||
				adminObj.adminType=="rh"))
			{
				trace("|###| AdminManager.adminCmd |###|>  <SETMOD>  adminClientID: "+msgObj.clientID+"  adminAccctID: "+msgObj.acctID+"  adminUserID: "+msgObj.userID+"  roomName: "+msgObj.roomName+"  selectedUserAcctID: "+msgObj.selectedUserAcctID+"  selectedUserID: "+msgObj.selectedUserID+"  propName: "+msgObj.propName+"  propVal: "+msgObj.propVal);
				
				// TEMP: trust the client to provide the propName
				//msgObj.propName = 'admin_level'; // set to match the mysql db, but use adminType on the media server
				
				this.setUserProperty(msgObj.clientID, msgObj.acctID, msgObj.userID, msgObj.adminPass, msgObj.roomName, msgObj.selectedUserAcctID, msgObj.selectedUserID, msgObj.propName, msgObj.propVal);
			}
		break;
		case "gag":
			if ((selectedUserObj)&&
				(adminObj.adminType=="sa"||
				adminObj.adminType=="ga"||
				adminObj.adminType=="rh"||
				adminObj.adminType=="ra"||
				adminObj.adminType=="rm"))
			{
				this.gagUser(msgObj.userID, msgObj.selectedUserID, msgObj.reason);
			}
		break;
		case "ungag":
			if ((selectedUserObj)&&
				(adminObj.adminType=="sa"||
				adminObj.adminType=="ga"||
				adminObj.adminType=="rh"||
				adminObj.adminType=="ra"||
				adminObj.adminType=="rm"))
			{
				this.ungagUser(msgObj.userID, msgObj.selectedUserID, msgObj.reason);
			}
		break;
		case "kick":
			if ((selectedUserObj)&&
				(adminObj.adminType=="sa"||
				adminObj.adminType=="ga"||
				adminObj.adminType=="rh"||
				adminObj.adminType=="ra"||
				adminObj.adminType=="rm") ||
				(adminObj.userID == selectedUserObj.userID) || 
				((adminObj.acctID != 0) && 
				(adminObj.acctID == selectedUserObj.acctID)))
			{
				this.kickUser(msgObj.userID, msgObj.selectedUserID, msgObj.reason);
			}
		break;
		case "ban":
			if ((selectedUserObj)&&
				(adminObj.adminType=="sa"||
				adminObj.adminType=="ga"||
				adminObj.adminType=="rh"||
				adminObj.adminType=="ra"))
			{
				this.banUser(msgObj.userID, msgObj.selectedUserID, msgObj.reason);
			}
		break;
		case "banip":
			if (adminObj.adminType=="sa"||
				adminObj.adminType=="ga"||
				adminObj.adminType=="rh")
			{
				this.banIP(msgObj.userID, msgObj.selectedUserID, msgObj.bannedIP, msgObj.reason);
			}
		break;
		case "unban":
			if (adminObj.adminType=="sa"||
				adminObj.adminType=="ga"||
				adminObj.adminType=="rh"||
				adminObj.adminType=="ra")
			{
				this.unbanUser(msgObj.userID, msgArr[1]);
			}
		break;
		case "unbanip":
			if (adminObj.adminType=="sa"||
				adminObj.adminType=="ga"||
				adminObj.adminType=="rh")
			{
				this.unbanIP(msgObj.userID, msgArr[1]);
			}
		break;
		case "version":
			if (adminObj.adminType=="sa"||
				adminObj.adminType=="ga")
			{
				if (msgArr[1])
				{
					var newVerString = msgArr[1] ? msgArr[1].toString().toLowerCase() : '';
					var soPropName = newVerString.charAt(0) == '3' ? 'version' : 'beta';
					
					// set new version to the first argument in the command (dangerous)
					if ((newVerString != "this") && 
						(soPropName == 'version' || soPropName == 'beta'))
					{
						application.userManager.versionSO.setProperty(soPropName, newVerString);
						application.userManager.versionSO.flush();
						msgObj.msg = 'New minimum ' + (soPropName == 'beta' ? soPropName.toUpperCase() : '') + ' version:  ' + newVerString;
						
						adminObj.call("showAdminMessage", null, msgObj);
					} else if (newVerString == "this") {
						// use the clients' current version as the new minimum version
						var newVersionName = adminObj.version.toString().charAt(0) == '3' ? 'version' : 'beta';
						
						application.userManager.versionSO.setProperty(newVersionName, adminObj.version);
						application.userManager.versionSO.flush();
						msgObj.msg = 'New minimum ' + (newVersionName == 'beta' ? newVersionName.toUpperCase() : '') + ' version:  ' + adminObj.version;
						
						adminObj.call("showAdminMessage", null, msgObj);
						
						newVersionName = null;
					}
					
					soPropName = null;
					newVerString = null;
				} else {
					sendClientServerVersion(msgObj.clientID);
				}
			} else {
				sendClientServerVersion(msgObj.clientID);
			}
		break;
		case "guests":
			if (adminObj.adminType=="sa"||
				adminObj.adminType=="ga"||
				adminObj.adminType=="rh"||
				adminObj.adminType=="ra")
			{
				this.setGuestAccess(msgObj.clientID, msgObj.msg.slice(indexOfFirstSpace, msgObj.msg.length).toLowerCase());
			}
		break;
		case "addbot":
			if (adminObj.adminType=="sa"||
				adminObj.adminType=="ga")
			{
				var tmpStr = msgObj.msg.slice(indexOfFirstSpace, msgObj.msg.length);
				
				if ((tmpStr) && 
					(tmpStr.length))
					this.addBot(adminObj.clientID, tmpStr);
				
				tmpStr = null;
			}
		break;
		case "delbot":
			if (adminObj.adminType=="sa"||
				adminObj.adminType=="ga")
			{
				var tmpStr = msgObj.msg.slice(indexOfFirstSpace, msgObj.msg.length);
				
				if ((tmpStr) && 
					(tmpStr.length))
					this.delBot(msgObj.clientID, tmpStr);
				
				tmpStr = null;
			}
		break;
		case "stats":
			if (msgObj.userID == selectedUserObj.userID ||
				(adminObj.adminType == "sa" ||
				adminObj.adminType == "ga" ||
				adminObj.adminType == "rh"))
			{
				if ((msgObj.selectedUserID != "undefined") &&
					(selectedUserObj))
				{
					trace("### GET STATS CALLED ###> "+adminObj.userName+" used getStats on "+selectedUserObj.userName);
					msgObj.msg = "STATS for <"+selectedUserObj.userName+">\n";
					msgObj.msg += "* Username:  "+selectedUserObj.userName+"\n";
					msgObj.msg += "* User ID:  "+selectedUserObj.userID+"\n";
					msgObj.msg += "* Account Name:  "+selectedUserObj.acctName+"\n";
					msgObj.msg += "* Account ID:  "+selectedUserObj.acctID+"\n";
					msgObj.msg += "* Quality:  "+selectedUserObj.defaultQuality+"\n";
					msgObj.msg += "* Protocol:  "+selectedUserObj.connectionProtocol+"\n";
					msgObj.msg += "* Ping:  "+selectedUserObj.getStats().ping_rtt+"\n";
					msgObj.msg += "* Version:  "+selectedUserObj.version+"\n";
					
					var stats = selectedUserObj.getStats();
					for (var prop in stats)
					{
						trace("\t"+"stats." + prop + " = " + stats[prop]);
						msgObj.msg += "*\tstats."+prop+":  "+stats[prop]+"\n";
					}
					
					adminObj.call("showAdminMessage", null, msgObj);
					prop = null;
					stats = null;
				}
			}
		break;
		case "whois":
				trace("### WHOIS CALLED ###> "+adminObj.userName+" used whois on "+selectedUserObj.userName);
			if ((msgObj.selectedUserID != "undefined") &&
				(selectedUserObj))
			{
				msgObj.msg = "WHOIS <"+selectedUserObj.userName+">\n";
				msgObj.msg += "* Username:  "+selectedUserObj.userName+"\n";
				msgObj.msg += "* User ID:  "+selectedUserObj.userID+"\n";
				msgObj.msg += "* Account Name:  "+selectedUserObj.acctName+"\n";
				msgObj.msg += "* Account ID:  "+selectedUserObj.acctID+"\n";
				msgObj.msg += "* Quality:  "+selectedUserObj.defaultQuality+"\n";
				msgObj.msg += "* Protocol:  "+selectedUserObj.connectionProtocol+"\n";
				msgObj.msg += "* Ping:  "+selectedUserObj.getStats().ping_rtt+"\n";
				msgObj.msg += "* Version:  "+selectedUserObj.version+"\n";
				
				if (adminObj.adminType == "sa" ||
					adminObj.adminType == "ga")
				{
					msgObj.msg += "* Client ID:  "+selectedUserObj.id+"\n";
					msgObj.msg += "* User IP:  "+selectedUserObj.ip+"\n";
				} else if (adminObj.adminType == "rh") {
					msgObj.msg += "* User IP:  "+selectedUserObj.ip+"\n";
				}
				
				switch (selectedUserObj.adminType)
				{
					case "sa" :
						msgObj.msg += "* Admin Type:  sa | Super Admin"+"\n";
						break;
					case "ga" :
						msgObj.msg += "* Admin Type:  ga | Global Admin";
						break;
					case "rh" :
						msgObj.msg += "* Admin Type:  rh | Room Host"+"\n";
						break;
					case "ra" :
						msgObj.msg += "* Admin Type:  ra | Room Admin"+"\n";
						break;
					case "rm" :
						msgObj.msg += "* Admin Type:  rm | Room Moderator"+"\n";
						break;
					default :
						msgObj.msg += "* Admin Type:  notadmin | Not Admin"+"\n";
						break;
				}
				
				if (selectedUserObj.compatibilityInfoObj)
				{
					msgObj.msg += "\n"+"* Compatibility Info:"+"\n";
					
					for (var i in selectedUserObj.compatibilityInfoObj)
					{
						msgObj.msg += i + " = " + selectedUserObj.compatibilityInfoObj[i] +"\n";
					}
					
					i = null;
				}
				
				msgObj.msg = parseOutHTML(msgObj.msg + "\n");
				
				adminObj.call("showAdminMessage", null, msgObj);
			}
		break;
		case "banlist":
			if (adminObj.adminType=="sa"||
				adminObj.adminType=="ga"||
				adminObj.adminType=="rh"||
				adminObj.adminType=="ra")
			{
				this.onRequestOfBannedUsers(msgObj.userID);
			}
		break;
		case "blocklist":
			if (adminObj.acctID != 0)
			{
				this.getBlockedUsersList(adminObj.userID);
			}
		break;/*
		case "fixblocks":
			if (adminObj.adminType=="sa"||
				adminObj.adminType=="ga")
			{
				this.fixBlocks(adminObj.clientID, (msgArr.length > 1 ? msgArr[1] : adminObj.acctID));
			}
		break;*/
		case "getip":
			if (adminObj.adminType=="sa"||
				adminObj.adminType=="ga"||
				adminObj.adminType=="rh"||
				adminObj.adminType=="ra")
			{
				this.getUserIP(msgObj);
			}
		break;
		case "ignore":
			this.ignoreUser(msgObj);
		break;
		case "unignore":
			this.unignoreUser(msgObj);
		break;
		case "debug":
			if (adminObj.adminType=="sa"||
				adminObj.adminType=="ga")
			{
				var tmpStr = msgObj.msg.toLowerCase().slice(indexOfFirstSpace, msgObj.msg.length);
				
				if ((!tmpStr) || 
					(!tmpStr.length) ||
					(tmpStr == "debug"))
				{
					msgObj.msg = "Server debug mode is currently:  ";
					msgObj.msg += (application.allowDebug ? "ENABLED" : "DISABLED");
					
					adminObj.call("showAdminMessage", false, msgObj);
					
					trace("### DEBUGMODE CALLED ###>  adminObj.userName: "+adminObj.userName+"  adminObj.adminType: "+adminObj.adminType+"  msgObj.msg: "+msgObj.msg);
					
					return;
				}
				
				application.allowDebug = (tmpStr == 'on' ? true : false);
				
				msgObj.msg = "Server debug mode is now:  ";
				msgObj.msg += (application.allowDebug ? "ENABLED" : "DISABLED");
				
				adminObj.call("showAdminMessage", false, msgObj);
				
				trace("### DEBUGMODE CHANGED ###>  adminObj.userName: "+adminObj.userName+"  msgObj.msg: "+msgObj.msg+"  tmpStr: "+tmpStr);
				
				tmpStr = null;
			}
		break;
	}
	
	adminObj = null;
	selectedUserObj = null;
	indexOfFirstSpace = null;
	msgArr = null;
	msgObj = null;
}


AdminManager.prototype.getUserProperty = function(clientID, targetUserAcctID, propName) // returns an Object
{
	var adminClientObj = application.userManager.getClientFromClientID(clientID);
	if (!adminClientObj) return;
	
	trace("AdminManager.getUserProperty->  adminClientObj: "+adminClientObj+"  targetUserAcctID: "+targetUserAcctID+"  propName: "+propName);
	
	var p_requestLoadVars = new LoadVars();
	var result_lv = new LoadVars();
	
	p_requestLoadVars.sendRequest = 'user_getinfo';
	p_requestLoadVars.parm1 = 'getmod';
	p_requestLoadVars.parm2 = adminClientObj.id.toString().substr(10, 18); // send only the last half of the adminClientID
	p_requestLoadVars.parm3 = targetUserAcctID;
	p_requestLoadVars.parm4 = propName; // unused, manually set
	
	p_requestLoadVars.sendAndLoad("http://www.toketub.tv/login/mod.php", result_lv, "POST");
	
	trace("AdminManager.getUserProperty.p_requestLoadVars->  <REQUEST SENT>  loaded: "+p_requestLoadVars.loaded);
	
	result_lv.onLoad = function(success)
	{
		trace("AdminManager.getUserProperty.result_lv.onLoad->  success: "+success+"  result_lv: "+unescape(this.toString()));
		trace("AdminManager.getUserProperty.result_lv->  this: "+this+"  status: "+this.status+"  ok: "+this.ok+"  admin_clientid: "+this.admin_clientid+"  target_acctid: "+this.target_acctid+"  adminType: "+this.admintype);
		
		var _adminClientObj = application.userManager.getClientFromClientID(this.admin_clientid, true); // match only the last half of the adminClientID
		if (!_adminClientObj) return;
		
		var resultObj = new Object();
		resultObj.ok = this.ok;
		resultObj.status = (((this.status) && (this.status.length)) ? this.status : "No status received");
		resultObj.admin_clientid = this.admin_clientid.toString();
		resultObj.target_acctid = this.target_acctid;
		resultObj.resultAdminType = unescape(this.admintype);
		
		if (this.ok == 1)
		{
			trace("AdminManager.getUserProperty.this.onLoad->  <getmod SUCCESS>  _adminClientObj: "+_adminClientObj+"  admin_clientid: "+resultObj.admin_clientid+"  adminType: "+resultObj.resultAdminType);
			
			// send the results to the client that requested the info
			_adminClientObj.call("onGetUserPropertyResult", null, resultObj);
		} else {
			trace("AdminManager.getUserProperty.this.onLoad->  <getmod FAILED>  _adminClientObj: "+_adminClientObj+"  admin_clientid: "+resultObj.admin_clientid+"  adminType: "+resultObj.resultAdminType+"  error: "+this.error);
		}
		
		_adminClientObj = null;
		resultObj = null;
	}
	
	result_lv = null;
	p_requestLoadVars = null;
	adminClientObj = null;
}


AdminManager.prototype.setUserProperty = function(adminClientID, adminAcctID, adminUserID, adminPass, targetRoomName, targetUserAcctID, targetUserID, propName, propVal)
{
	var adminClientObj = application.userManager.getClientFromClientID(adminClientID);
	
	if (!adminClientObj) return;
	
	trace("AdminManager.setUserProperty->  adminClientObj: "+adminClientObj+"  adminName: "+adminClientObj.userName+"  targetUserAcctID: "+targetUserAcctID+"  propName: "+propName+"  propVal: "+propVal);
	
	var p_requestLoadVars = new LoadVars();
	var result_lv = new LoadVars();
	
	p_requestLoadVars.sendRequest = 'user_modify';
	
	p_requestLoadVars.parm1 = 'setmod'; // TEMP
	p_requestLoadVars.parm2 = adminClientObj.clientID.toString().substr(10, 18); // send only the last half of the adminClientID
	p_requestLoadVars.parm3 = adminAcctID;
	p_requestLoadVars.parm4 = adminPass;
	p_requestLoadVars.parm5 = targetRoomName;
	p_requestLoadVars.parm6 = targetUserAcctID;
	p_requestLoadVars.parm7 = propName;
	p_requestLoadVars.parm8 = propVal;
	
	p_requestLoadVars.sendAndLoad("http://www.toketub.tv/login/mod.php", result_lv, "POST");
	
	trace("AdminManager.setUserProperty.p_requestLoadVars->  <REQUEST SENT>  loaded: "+p_requestLoadVars.loaded);
	
	result_lv.onLoad = function(success)
	{
		trace("AdminManager.setUserProperty.result_lv.onLoad->  success: "+success+"  result_lv: "+unescape(this.toString()));
		trace("AdminManager.setUserProperty.result_lv->  this: "+this+"  status: "+this.status+"  ok: "+this.ok+"  admin_clientid: "+this.admin_clientid+"  target_acctid: "+this.target_acctid+"  adminType: "+this.admintype);
		
		var _adminClientObj = application.userManager.getClientFromClientID(this.admin_clientid, true); // match only the last half of the adminClientID
		if (!_adminClientObj) return;
		
		var resultObj = new Object();
		resultObj.ok = this.ok;
		resultObj.status = (((this.status) && (this.status.length)) ? this.status : "No status received");
		resultObj.admin_clientid = this.admin_clientid.toString();
		resultObj.target_acctid = this.target_acctid;
		resultObj.newAdminType = unescape(this.new_admintype);
		
		if (this.ok == 1)
		{
			trace("AdminManager.setUserProperty.this.onLoad->  <setmod SUCCESS>  _adminClientObj: "+_adminClientObj+"  admin_clientid: "+resultObj.admin_clientid+"  newAdminType: "+resultObj.newAdminType);
			
			// send the results to the client that requested the info
			_adminClientObj.call("onSetUserPropertyResult", null, resultObj);
		} else {
			trace("AdminManager.setUserProperty.this.onLoad->  <setmod FAILED>  _adminClientObj: "+_adminClientObj+"  admin_clientid: "+resultObj.admin_clientid+"  newAdminType: "+resultObj.newAdminType+"  error: "+this.error);
		}
		
		resultObj = null;
		_adminClientObj = null;
	}
	
	result_lv = null;
	p_requestLoadVars = null;
	adminClientObj = null;
}


AdminManager.prototype.gagUser = function(adminID, userID, reason)
{
	var adminObj = application.userManager.users["user_"+adminID];
	var userObj = application.userManager.users["user_"+userID];
	
	trace("AdminManager.gagUser>  "+adminObj.userName+" ("+adminObj.adminType+")"+" is GAGGING "+userObj.userName+" ("+userObj.adminType+")");
	
	var msgObj = new Object();
	
	// super and global admins can gag anyone
	if (adminObj.adminType=="sa"||
		adminObj.adminType=="ga")
	{
		gag();
	// room hosts can only gag their rooms admins
	} else if ((adminObj.adminType=="rh")&&
				(userObj.adminType!="sa"&&
				userObj.adminType!="ga"&&
				userObj.adminType!="rh"))
	{
		gag();
	// room admins can gag mods but not other admins or the room host
	} else if ((adminObj.adminType=="ra")&&
				(userObj.adminType!="sa"&&
				userObj.adminType!="ga"&&
				userObj.adminType!="rh"&&
				userObj.adminType!="ra"))
	{
		gag();
	// room mods cant gag other admins or mods
	} else if ((adminObj.adminType=="rm")&&
				(userObj.adminType!="sa"&&
				userObj.adminType!="ga"&&
				userObj.adminType!="rh"&&
				userObj.adminType!="ra"&&
				userObj.adminType!="rm"))
	{
		gag();
	// admins/mods can gag themself or their clones
	} else if ((adminObj.acctID != 0) && 
				(adminObj.acctID == userObj.acctID))
	{
		gag();
	} else {
		msgObj.msg = "You cannot gag another mod or admin!";
		adminObj.call("showAdminMessage", null, msgObj);
	}
	
	function gag()
	{
		trace("#GAGGING USER#>  admin: "+adminObj.userName+" ("+adminObj.adminType+")"+" GAGGED  userID: "+userID+"  userName: "+userObj.userName+" ("+userObj.admiinType+")"+"  reason: "+reason)
		
		var tmpObj = new Object();
		tmpObj.adminname = adminObj.userName;
		tmpObj.gagTime = 0;
		tmpObj.gagDate = new Date();
		tmpObj.reason = reason;
		
		userObj.isGagged = true;
		
		//userObj.call("gagged", null, tmpObj);
		
		msgObj.msg = adminObj.userName+" gagged "+userObj.userName+" for:  "+reason;
		
		application.broadcastMsg("showAdminMessage", msgObj);
		
		tmpObj = null;
	}
	
	i = null;
	msgObj = null;
	userObj = null;
	adminObj = null;
	reason = null;
	userID = null;
	adminID = null;
}


AdminManager.prototype.ungagUser = function(adminID, userID, reason)
{
	var adminObj = application.userManager.users["user_"+adminID];
	var userObj = application.userManager.users["user_"+userID];
	
	trace("AdminManager.gagUser>  "+adminObj.userName+" ("+adminObj.adminType+")"+" is UNGAGGING "+userObj.userName+" ("+userObj.adminType+")");
	
	var msgObj = new Object();
	
	// super and global admins can ungag anyone
	if (adminObj.adminType=="sa"||
		adminObj.adminType=="ga")
	{
		ungag();
	// room hosts can ungag their admins and mods
	} else if ((adminObj.adminType=="rh")&&
				(userObj.adminType!="sa"&&
				userObj.adminType!="ga"))
	{
		ungag();
	// room admins can ungag mods but not other admins or mods
	} else if ((adminObj.adminType=="ra")&&
				(userObj.adminType!="sa"&&
				userObj.adminType!="ga"&&
				userObj.adminType!="rh"&&
				userObj.adminType!="ra"))
	{
		ungag();
	// room mods cant ungag other admins or mods
	} else if ((adminObj.adminType=="rm")&&
				(userObj.adminType!="sa"&&
				userObj.adminType!="ga"&&
				userObj.adminType!="ra"&&
				userObj.adminType!="rh"&&
				userObj.adminType!="rm"))
	{
		ungag();
	// admins/mods can ungag themself or their clones
	} else if (adminObj.acctID==userObj.acctID)
	{
		ungag();
	} else {
		msgObj.msg = "You cannot ungag another mod or admin!";
		adminObj.call("showAdminMessage", null, msgObj);
	}
	
	function ungag()
	{
		trace("#UNGAGGING USER#>  admin: "+adminObj.userName+" ("+adminObj.adminType+")"+" UNGAGGED  userID: "+userID+"  userName: "+userObj.userName+" ("+userObj.adminType+")"+"  reason: "+reason)
		
		userObj.isGagged = false;
		
		//var tmpObj = new Object();
		//tmpObj.adminname = adminObj.userName;
		
		//userObj.call("ungagged", null, tmpObj);
		
		msgObj.msg = adminObj.userName+" ungagged "+userObj.userName;
		
		application.broadcastMsg("showAdminMessage", msgObj);
		
		//tmpObj = null;
	}
	i = null;
	msgObj = null;
	userObj = null;
	adminObj = null;
	reason = null;
	userID = null;
	adminID = null;
}


AdminManager.prototype.kickUser = function(adminID, userID, reason)
{
	var adminObj = application.userManager.users["user_"+adminID];
	var userObj = application.userManager.users["user_"+userID];
	
	if (!adminObj || !userObj)
		return;
	
	trace("AdminManager.kickUser>  "+adminObj.userName+" ("+adminObj.adminType+")"+" IS KICKING "+userObj.userName+" ("+userObj.adminType+")");
	
	var msgObj = new Object();
	// super admins can kick anyone
	if (adminObj.adminType=="sa")
	{
		kick();
	// global admins can kick all room mods and room admins
	} else if ((adminObj.adminType=="ga")&&
				(userObj.adminType!="sa"&&
				userObj.adminType!="ga"))
	{
		kick();
	// room admins can kick mods but not other admins
	} else if ((adminObj.adminType=="rh")&&
				(userObj.adminType!="sa"&&
				userObj.adminType!="ga"&&
				userObj.adminType!="rh"))
	{
		kick();
	// room admins can kick mods but not other admins
	} else if ((adminObj.adminType=="ra")&&
				(userObj.adminType!="sa"&&
				userObj.adminType!="ga"&&
				userObj.adminType!="rh"&&
				userObj.adminType!="ra"))
	{
		kick();
	// room mods cant kick other admins or mods
	} else if ((adminObj.adminType=="rm")&&
				(userObj.adminType!="sa"&&
				userObj.adminType!="ga"&&
				userObj.adminType!="rh"&&
				userObj.adminType!="ra"&&
				userObj.adminType!="rm"))
	{
		kick();
	// admins/mods can kick themselves/clones
	} else if ((adminObj.acctID != 0) && 
				(adminObj.acctID == userObj.acctID))
	{
		kick();
	} else {
		msgObj.msg = "You cannot kick that user!";
		adminObj.call("showAdminMessage", null, msgObj);
	}
	
	function kick()
	{
		trace("#KICKING USER#>  admin: "+adminObj.userName+" ("+adminObj.adminType+")"+" KICKED  userID: "+userID+"  userName: "+userObj.userName+" ("+userObj.adminType+")"+"  reason: "+reason)
		msgObj.msg = adminObj.userName+" kicked "+userObj.userName+" for:  "+reason;
		application.broadcastMsg("showAdminMessage", msgObj);
		
		var tmpObj = new Object();
		tmpObj.adminname = adminObj.userName;
		tmpObj.kickTime = 0;
		tmpObj.kickDate = new Date();
		tmpObj.reason = reason;
		userObj.call("kicked", null, tmpObj);
		userObj.kickInterval = setInterval(kickOutUser, 1000, userObj);
		tmpObj = null;
	}
	
	i = null;
	msgObj = null;
	userObj = null;
	adminObj = null;
	reason = null;
	userID = null;
	adminID = null;
}


AdminManager.prototype.banUser = function(adminID, userID, reason)
{
	var adminObj = application.userManager.users["user_"+adminID];
	var userObj = application.userManager.users["user_"+userID];
	var msgObj = new Object();
	
	trace("#BANNING USER#>  admin: "+adminObj.userName+"  adminType: "+adminObj.adminType+" BANNED  userID: "+userID+"  userName: "+userObj.userName+"  adminType: "+userObj.adminType+"  banTime: "+0+"  reason: "+reason+"  this.bannedUsers: "+this.bannedUsers);
	
	// super and global admins can ban anyone
	
	if (adminObj.adminType=="sa"||
		adminObj.adminType=="ga")
	{
		ban(adminObj, userObj);
	// room admins can kick mods but not other admins
	} else if ((adminObj.adminType=="rh")&&
				(userObj.adminType!="sa"&&
				userObj.adminType!="ga"&&
				userObj.adminType!="rh"))
	{
		ban(adminObj, userObj);
/*	// room admins can ban mods but not other admins
	} else if ((adminObj.adminType=="ra")&&
				(userObj.adminType!="sa"&&
				userObj.adminType!="ga"&&
				userObj.adminType!="ra"))
	{
		ban(adminObj, userObj);
*/	// room mods cant ban other admins or mods
	} else if ((adminObj.adminType=="ra")&&
				(userObj.adminType!="sa"&&
				userObj.adminType!="ga"&&
				userObj.adminType!="rh"&&
				userObj.adminType!="ra"&&
				userObj.adminType!="rm"))
	{
		ban(adminObj, userObj);
	} else {
		msgObj.msg = "You cannot ban another admin/mod!";
		adminObj.call("showAdminMessage", null, msgObj);
	}
	
	function ban(adminObj, userObj)
	{
		application.adminManager.bannedUsers["BAN_" + userObj.ip] = new Object();
		application.adminManager.bannedUsers["BAN_" + userObj.ip].ip = userObj.ip;
		application.adminManager.bannedUsers["BAN_" + userObj.ip].adminname = adminObj.userName;
		application.adminManager.bannedUsers["BAN_" + userObj.ip].adminacctname = adminObj.acctName;
		application.adminManager.bannedUsers["BAN_" + userObj.ip].adminacctid = adminObj.acctID;
		application.adminManager.bannedUsers["BAN_" + userObj.ip].username = userObj.userName;
		application.adminManager.bannedUsers["BAN_" + userObj.ip].acctname = userObj.acctName;
		application.adminManager.bannedUsers["BAN_" + userObj.ip].acctid = userObj.acctID;
		application.adminManager.bannedUsers["BAN_" + userObj.ip].reason = reason;
		application.adminManager.bannedUsers["BAN_" + userObj.ip].banTime = 0;
		application.adminManager.bannedUsers["BAN_" + userObj.ip].banDate = new Date();
		
		application.adminManager.saveBannedUsers();
		
		msgObj.msg = adminObj.userName + " banned " + userObj.userName + " for:  " + reason;
		
		application.broadcastMsg("showAdminMessage", msgObj);
		
		var tmpObj = new Object();
		tmpObj.adminname = adminObj.userName;
		tmpObj.banTime = 0;
		tmpObj.banDate = application.adminManager.bannedUsers["BAN_" + userObj.ip].banDate;
		tmpObj.reason = reason;
		
		userObj.call("banned", null, tmpObj);
		
		userObj.kickInterval = setInterval(kickOutUser, 1000, userObj);
		
		tmpObj = null;
		userObj = null;
		adminObj = null;
	}
	
	i = null;
	msgObj = null;
	adminID = null;
	userID = null;
	reason = null;
	userObj = null;
	adminObj = null;
}


AdminManager.prototype.banIP = function(adminID, userID, bannedIP, reason)
{
	var ip = parseIP(bannedIP.length);
	
	if (application.userManager.users["user_"+adminID].adminType=="sa"||
		application.userManager.users["user_"+adminID].adminType=="ga")
	{
		application.adminManager.bannedUsers["BANNEDIP_"+ip] = new Object();
		application.adminManager.bannedUsers["BANNEDIP_"+ip].ip = bannedIP;
		application.adminManager.bannedUsers["BANNEDIP_"+ip].adminname = application.userManager.users["user_"+adminID].userName;
		application.adminManager.bannedUsers["BANNEDIP_"+ip].reason = reason;
		application.adminManager.bannedUsers["BANNEDIP_"+ip].banTime = 0;
		application.adminManager.bannedUsers["BANNEDIP_"+ip].banDate = new Date();
		application.adminManager.saveBannedUsers();
	}
	
	function parseIP(iplength)
	{
		var str = new String();
		switch (iplength)
		{
			case 1:
				trace("banIP.parseIP>  CLASS A");
				str = bannedIP[0].toString()+".0.0.0";
			break;
			case 2:
				trace("banIP.parseIP>  CLASS B");
				str = bannedIP[0].toString()+"."+bannedIP[1].toString()+".0.0";
			break;
			case 3:
				trace("banIP.parseIP>  CLASS C");
				str = bannedIP[0].toString()+"."+bannedIP[1].toString()+"."+bannedIP[2].toString()+".0";
			break;
			case 4:
				trace("banIP.parseIP>  CLASS D");
				str = bannedIP[0].toString()+"."+bannedIP[1].toString()+"."+bannedIP[2].toString()+"."+bannedIP[3].toString();
			break;
		}
		return str;
		str = null;
	}
	
	trace("banIP>  bannedIP: "+bannedIP+"  iplength: "+bannedIP.length+"  isUserBanned: "+application.adminManager.isUserBanned(ip));
	
	adminID = null;
	userID = null;
	bannedIP = null;
	reason = null;
	ip = null;
}


AdminManager.prototype.unbanUser = function(adminID, ip)
{
	if (this.bannedUsers["BAN_" + ip])
	{
		delete this.bannedUsers["BAN_" + ip];
		this.saveBannedUsers();
		var msgObj = new Object();
		msgObj.msg = "Unbanned IP: "+ip;
		application.userManager.users["user_"+adminID].call("showAdminMessage", null, msgObj);
		msgObj = null;
	}
	adminID = null;
	ip = null;
}


AdminManager.prototype.unbanIP = function(adminID, ip)
{
	if (this.bannedUsers["BANNEDIP_" + ip])
	{
		delete this.bannedUsers["BANNEDIP_" + ip];
		
		this.saveBannedUsers();
		
		var msgObj = new Object();
		msgObj.msg = "Unbanned IP: "+ip;
		
		application.userManager.users["user_"+adminID].call("showAdminMessage", null, msgObj);
		
		msgObj = null;
	}
	adminID = null;
	ip = null;
}


AdminManager.prototype.getUserIP = function(msgObj)
{
	if (application.userManager.users["user_"+msgObj.userID].adminType=="sa"||
		application.userManager.users["user_"+msgObj.userID].adminType=="ga"||
		application.userManager.users["user_"+msgObj.userID].adminType=="rh"||
		application.userManager.users["user_"+msgObj.userID].adminType=="ra")
	{
		application.userManager.users["user_"+msgObj.userID].call("getUserIP", null, application.userManager.users["user_"+msgObj.selectedUserID].ip);
	}
	
	msgObj = null;
}


AdminManager.prototype.onRequestOfBannedUsers = function(adminID)
{
	trace("AdminManager.onRequestOfBannedUsers>  called by "+application.userManager.users["user_"+adminID].userName);
	
	if (application.userManager.users["user_"+adminID].adminType=="sa"||
		application.userManager.users["user_"+adminID].adminType=="ga"||
		application.userManager.users["user_"+adminID].adminType=="rh"||
		application.userManager.users["user_"+adminID].adminType=="ra")
	{
		application.userManager.users["user_" + adminID].call("receiveBannedUsers", null, this.getBannedUsers());
	}
	
	adminID = null;
}


AdminManager.prototype.getBannedUsers = function()
{
	return this.bannedUsers;
}


AdminManager.prototype.saveBannedUsers = function()
{
	trace("#SAVING BANNED USERS#> "+new Date());
	
	this.bannedUsersSO.setProperty("bannedUsers", this.bannedUsers);
	this.bannedUsersSO.flush();
}


AdminManager.prototype.saveBlockedUsers = function()
{
	trace("#SAVING BLOCKED USERS#> "+new Date());
	
	this.userIgnoresSO.setProperty("userIgnores", this.userIgnores);
	this.userIgnoresSO.flush();
}


AdminManager.prototype.setGuestAccess = function(clientID, onOff)
{
	var adminClientObj = application.userManager.getClientFromClientID(clientID);
	if (!adminClientObj) return;
	
	trace("### AdminManager.setGuestAccess CALLED ###>  adminClientObj: "+adminClientObj+"  onOff: "+onOff);
	
	if ((!adminClientObj) ||
		(adminClientObj.adminType!="sa" &&
		adminClientObj.adminType!="ga" &&
		adminClientObj.adminType!="rh" &&
		adminClientObj.adminType!="ra"))
		return;
	
	var msgObj = new Object();
	
	if ((onOff=="on")&&
		(this.guestAccessSO.getProperty("guestAccess")==false))
	{
		this.guestAccessSO.setProperty("guestAccess", true);
		msgObj.msg = adminClientObj.userName+" enabled guest access.";
		application.broadcastMsg("showAdminMessage", msgObj);
	} else if ((onOff=="off")&&(this.guestAccessSO.getProperty("guestAccess")==true)) {
		this.guestAccessSO.setProperty("guestAccess", false);
		msgObj.msg = adminClientObj.userName+" disabled guest access.";
		application.broadcastMsg("showAdminMessage", msgObj);
	} else {
		if (this.guestAccessSO.getProperty("guestAccess")==true)
		{
			msgObj.msg = "Guest access is currently:  ENABLED";
		} else {
			msgObj.msg = "Guest access is currently:  DISABLED";
		}
		
		adminClientObj.call("showAdminMessage", null, msgObj);
	}
	
	msgObj = null;
	adminClientObj = null;
	onOff = null;
	clientID = null;
}


AdminManager.prototype.getBlockedUsersList = function(clientID)
{
	var adminClientObj = application.userManager.getClientFromClientID(clientID);
	
	if (!adminClientObj) 
		return;
	
	if (adminClientObj.acctID != 0)
	{
		/*
		for (var i in this.userIgnores)
		{
			
		}
		
		i = null;
		*/
		if (this.userIgnores["member_"+adminClientObj.acctID])
			adminClientObj.call("getBlockedUsersList", null, this.userIgnores["member_"+adminClientObj.acctID]);
	} else {
		if (this.userIgnores["guest_"+adminClientObj.userID])
			adminClientObj.call("getBlockedUsersList", null, this.userIgnores["guest_"+adminClientObj.userID]);
	}
	
	adminClientObj = null;
	clientID = null;
}


// TEMP
AdminManager.prototype.fixBlocks = function(clientID, targetAcctID)
{
	if (clientID)
	{
		var adminObj = application.userManager.getClientFromClientID(clientID);
		
		if ((!adminObj) || 
			(adminObj.adminType != "sa" && 
			adminObj.adminType != "ga"))
		{
			return;
		}
		
		trace("AdminManager.fixBlocks->  adminObj: " + adminObj + "  adminType: " + adminObj.adminType + "  clientID: " + clientID + "  targetAcctID: " + targetAcctID);
	}
	
	var tmpBlockedUsersList = new Object();
	var numChildren = 0;
	var hasChanged = false;
	
	for (var i in this.userIgnores)
	{
		var doDelete = false;
		var numChildrenX = 0;
		
		++numChildren;
		
		trace("AdminManager.fixBlocks->  <FIXING>  this: " + this + "  numChildren: " + numChildren + "  <i:" + i + ":" + this.userIgnores[i] + ">"/* + "  <" + this.userIgnores[i][0].whoIgnoredName + ">"*/);
		
		for (var x in this.userIgnores[i])
		{
			++numChildrenX;
			
			var tmpArr = x.toString().split("_");
			if (!isNaN(tmpArr[tmpArr.length - 1]))
			{
				trace("-------------------------------  " + tmpArr[tmpArr.length - 1] + "  ---------------------------------------");
				
				this.userIgnores[i][x] = null;
				delete this.userIgnores[i][x];
				
				tmpArr = null;
				
				continue;
			}
			
			// go to the next item in the loop if the Object has been fixed already,
			// and has been renamed to guest_userName or member_acctID
			if ((x.toString().indexOf("guest_") != -1) && 
				(x.toString().indexOf("member_") != -1))
			{
				trace("AdminManager.fixBlocks->  <SKIPPING>  numChildren: " + numChildren + "  numChildrenX: " + numChildrenX + "  <i:" + i + ":" + this.userIgnores[i] + ">  <x:" + x + ":" + this.userIgnores[i][x] + ">");
				
				continue;
			}
			
			//trace("AdminManager.fixBlocks->  <FIXING>  this: " + this + "  numChildren: " + numChildren + "  numChildrenX: " + numChildrenX + "  <i:" + i + ":" + this.userIgnores[i] + ">  <x:" + x + ":" + this.userIgnores[i][x] + ">  =  " + this.userIgnores[i][x] + "  <whoIgnoredName:" + this.userIgnores[i][x].whoIgnoredName + ">" + "  <whoIgnoredAcctID:" + this.userIgnores[i][x].whoIgnoredAcctID + ">" + "  <ignoredWhoName:" + this.userIgnores[i][x].ignoredWhoName + ">" + "  <ignoredWhoAcctID:" + this.userIgnores[i][x].ignoredWhoAcctID + ">" + "  <ignoredAcctID:" + this.userIgnores[i][x].ignoredAcctID + ">");
			
			// ignoredAcctID to ignoredWhoAcctID
			//this.userIgnores[i][x].ignoredWhoAcctID = this.userIgnores[i][x].ignoredAcctID;
			
			//this.userIgnores[i][x].ignoredAcctID = null;
			//delete this.userIgnores[i][x].ignoredAcctID;
			
			// to help shorten the if's
			var ignoreInfo = this.userIgnores[i][x];
			ignoreInfo.ignoreDate = (this.userIgnores[i][x].ignoreDate ? this.userIgnores[i][x].ignoreDate : new Date().toString());
			
			var isAGuestIgnoring = (ignoreInfo.whoIgnoredAcctID == 0);
			//var isIgnoringAGuest = (ignoreInfo.ignoredWhoAcctID == 0);
			var isIgnoringAGuest = (ignoreInfo.ignoredAcctID == 0);
			var firstNodeName = (isAGuestIgnoring ? "guest_" + ignoreInfo.whoIgnoredID : "member_" + ignoreInfo.whoIgnoredAcctID);
			//var secondNodeName = (isIgnoringAGuest ? "guest_" + ignoreInfo.ignoredWhoName : "member_" + ignoreInfo.ignoredWhoAcctID);
			var secondNodeName = (isIgnoringAGuest ? "guest_" + ignoreInfo.ignoredWhoName : "member_" + ignoreInfo.ignoredAcctID);
			
			// create a new object named member_acctID or guest_userName,
			// and add it to the object containing the users ignores
			//if (((this.userIgnores[i][x].ignoredAcctID) && (this.userIgnores[i][x].ignoredAcctID == 0)) || 
			//	((this.userIgnores[i][x].ignoredWhoAcctID) && (this.userIgnores[i][x].ignoredWhoAcctID == 0)))
			//{
				trace("AdminManager.fixBlocks->  <FIXING>  this: " + this + "  numChildren: " + numChildren + "  numChildrenX: " + numChildrenX + "  <i:" + i + ":" + this.userIgnores[i] + ">  <x:" + x + ":" + this.userIgnores[i][x] + ">  =  " + this.userIgnores[i][x] + "  <whoIgnoredName:" + this.userIgnores[i][x].whoIgnoredName + ">" + "  <whoIgnoredAcctID:" + this.userIgnores[i][x].whoIgnoredAcctID + ">" + "  <ignoredWhoName:" + this.userIgnores[i][x].ignoredWhoName + ">" + "  <ignoredWhoAcctID:" + this.userIgnores[i][x].ignoredWhoAcctID + ">" + "  <ignoredAcctID:" + this.userIgnores[i][x].ignoredAcctID + ">  <ignoreInfo:" + ignoreInfo + ">  <isAGuestIgnoring:" + isAGuestIgnoring + ">  <isIgnoringAGuest:" + isIgnoringAGuest + ">  <firstNodeName:" + firstNodeName + ">  <secondNodeName:" + secondNodeName + ">");
				
				var tmpObj = new Object();
				tmpObj.ignoreDate = (ignoreInfo.ignoreDate ? ignoreInfo.ignoreDate : new Date().toString());
				tmpObj.whoIgnoredAcctID = ignoreInfo.whoIgnoredAcctID;
				tmpObj.whoIgnoredName = ignoreInfo.whoIgnoredName;
				tmpObj.whoIgnoredID = ignoreInfo.whoIgnoredID;
				//tmpObj.ignoredWhoAcctID = ignoreInfo.ignoredWhoAcctID;
				tmpObj.ignoredWhoAcctID = ignoreInfo.ignoredAcctID;
				tmpObj.ignoredWhoName = ignoreInfo.ignoredWhoName;
				tmpObj.ignoredWhoID = ignoreInfo.ignoredWhoID;
				
				//this.userIgnores[i][secondNodeName] = ignoreInfo;
				if (!this.userIgnores[i][secondNodeName])
					this.userIgnores[i][secondNodeName] = tmpObj;
				
				//this.userIgnores[i][x] = null;
				//delete this.userIgnores[i][x];
				doDelete = true; // delete this object after the loop
				hasChanged = true; // save the object to the SharedObject
				
				tmpObj = null;
				delete tmpObj;
				ignoreInfo = null;
				delete ignoreInfo;
			//}
			
			// just to trace the results
			//x = secondNodeName;
			
			trace("AdminManager.fixBlocks->  <FIXED>  this: " + this + "  numChildren: " + numChildren + "  numChildrenX: " + numChildrenX + "  <i:" + i + ":" + this.userIgnores[i] + ">  <x:" + secondNodeName + ":" + this.userIgnores[i][secondNodeName] + ">  =  " + this.userIgnores[i][secondNodeName] + "  <whoIgnoredName:" + this.userIgnores[i][secondNodeName].whoIgnoredName + ">" + "  <whoIgnoredAcctID:" + this.userIgnores[i][secondNodeName].whoIgnoredAcctID + ">  <ignoredWhoName:" + this.userIgnores[i][secondNodeName].ignoredWhoName + ">" + "  <ignoredWhoAcctID:" + this.userIgnores[i][secondNodeName].ignoredWhoAcctID + ">" + "  <ignoredAcctID:" + this.userIgnores[i][secondNodeName].ignoredAcctID + ">");
			
			//x = null;
			
			// TEMP
			//continue;
			
			
			
			/*******************************/
			/*
			if (!this.userIgnores[i][x])
			{
				trace("AdminManager.fixBlocks->  <ERROR_OBJ_UNDEFINED>  numChildren: " + numChildren + "  numChildrenX: " + numChildrenX + "  <i:" + i + ":" + this.userIgnores[i] + ">  <x:" + x + ":" + this.userIgnores[i][x] + ">");
				
				break;
			}
			
			// go to the next item in the loop if the Object has been fixed already,
			// and has been renamed to guest_userName or member_acctID
			if ((x.toString().indexOf("guest_") != -1) && 
				(x.toString().indexOf("member_") != -1))
			{
				trace("AdminManager.fixBlocks->  numChildren: " + numChildren + "  numChildrenX: " + numChildrenX + "  <SKIPPING>  <i:" + i + ":" + this.userIgnores[i] + ">  <x:" + x + ":" + this.userIgnores[i][x] + ">");
				
				continue;
			}
			
			// delete ignored guests and go to the next item in the for loop
			if (((this.userIgnores[i][x].ignoredAcctID) && (this.userIgnores[i][x].ignoredAcctID == 0)) || 
				((this.userIgnores[i][x].ignoredWhoAcctID) && (this.userIgnores[i][x].ignoredWhoAcctID == 0)) || 
				(this.userIgnores[i][x].ignoredAcctID == undefined) || 
				(this.userIgnores[i][x].ignoredWhoAcctID == undefined))
			{
				// delete ignored guest user
				this.userIgnores[i][x] = null;
				delete this.userIgnores[i][x];
				
				hasChanged = true;
				
				trace("AdminManager.fixBlocks->  numChildren: " + numChildren + "  numChildrenX: " + numChildrenX + "  <REMOVED>  <i:" + i + ":" + this.userIgnores[i] + ">  <x:" + x + ":" + this.userIgnores[i][x] + ">");
				
				// go to the next item in the for loop
				continue;
			}
			
			// stage 1
			
			// ignoredAcctID to ignoredWhoAcctID
			if (this.userIgnores[i][x].ignoredAcctID)
			{
				this.userIgnores[i][x].ignoredWhoAcctID = this.userIgnores[i][x].ignoredAcctID;
				
				this.userIgnores[i][x].ignoredAcctID = null;
				delete this.userIgnores[i][x].ignoredAcctID;
				
				hasChanged = true;
			}
			
			// add a Date
			if (!this.userIgnores[i][x].ignoreDate)
			{
				this.userIgnores[i][x].ignoreDate = new Date().toString();
				
				hasChanged = true;
			}
			
			// stage 2
			
			//var tmpObj = this.userIgnores[i][x];
			var tmpObj = new Object();
			tmpObj.ignoreDate = (this.userIgnores[i][x].ignoreDate) ? this.userIgnores[i][x].ignoreDate : new Date().toString();
			tmpObj.whoIgnoredAcctID = this.userIgnores[i][x].whoIgnoredAcctID;
			tmpObj.whoIgnoredName = this.userIgnores[i][x].whoIgnoredName;
			tmpObj.whoIgnoredID = this.userIgnores[i][x].whoIgnoredID;
			tmpObj.ignoredWhoAcctID = this.userIgnores[i][x].ignoredWhoAcctID;
			tmpObj.ignoredWhoName = this.userIgnores[i][x].ignoredWhoName;
			tmpObj.ignoredWhoID = this.userIgnores[i][x].ignoredWhoID;
			
			trace("AdminManager.fixBlocks->  numChildren: " + numChildren + "  numChildrenX: " + numChildrenX + "  <i:" + i + ":" + this.userIgnores[i] + ">  <x:" + x + ":" + this.userIgnores[i][x] + ">  =  " + this.userIgnores[i][x] + "  <whoIgnoredName:" + tmpObj.whoIgnoredName + ">" + "  <whoIgnoredAcctID:" + tmpObj.whoIgnoredAcctID + ">" + "  <ignoredWhoName:" + tmpObj.ignoredWhoName + ">" + "  <ignoredWhoAcctID:" + tmpObj.ignoredWhoAcctID + ">");
			
			// set the new info
			if (!tmpBlockedUsersList["member_" + tmpObj.whoIgnoredAcctID])
				tmpBlockedUsersList["member_" + tmpObj.whoIgnoredAcctID] = new Object();
			
			if (!tmpBlockedUsersList["member_" + tmpObj.whoIgnoredAcctID]["member_" + tmpObj.ignoredWhoAcctID])
				tmpBlockedUsersList["member_" + tmpObj.whoIgnoredAcctID]["member_" + tmpObj.ignoredWhoAcctID] = tmpObj;
			
			if (!this.userIgnores["member_" + tmpObj.whoIgnoredAcctID]["member_" + tmpObj.ignoredWhoAcctID])
				this.userIgnores["member_" + tmpObj.whoIgnoredAcctID]["member_" + tmpObj.ignoredWhoAcctID] = tmpObj;
			
			// delete the old object
			this.userIgnores[i][x] = null;
			delete this.userIgnores[i][x];
			
			hasChanged = true;
			
			tmpObj = null;
			
			if (doDelete)
			{
				this.userIgnores[i][x] = null;
				delete this.userIgnores[i][x];
				
				doDelete = false;
			}
			*/
		}// end for x in userIgnores[i]
		
		if (doDelete)
		{
			this.userIgnores[i][x] = null;
			delete this.userIgnores[i][x];
			
			doDelete = false;
		}
		
		if (numChildrenX == 0)
		{
			this.userIgnores[i] = null;
			delete this.userIgnores[i];
			
			doDelete = false;
		}
		
		x = null;
	}// end for i in userIgnores
	/*
	for (var y in application.adminManager.userIgnores)
	{
		for (var z in application.adminManager.userIgnores[y])
		{
			if ((application.adminManager.userIgnores[y][z]) &&
				(application.adminManager.userIgnores[y][z].ignoredWhoAcctID == undefined))
			{
				trace("AdminManager.fixBlocks->  <DELETING>  this: " + this + "  <y:" + y + ":" + this.userIgnores[y] + ">  <z:" + z + ":" + this.userIgnores[y][z] + ">  =  " + this.userIgnores[y][z] + "  <whoIgnoredName:" + this.userIgnores[y][z].whoIgnoredName + ">" + "  <whoIgnoredAcctID:" + this.userIgnores[y][z].whoIgnoredAcctID + ">" + "  <ignoredWhoName:" + this.userIgnores[y][z].ignoredWhoName + ">" + "  <ignoredWhoAcctID:" + this.userIgnores[y][z].ignoredWhoAcctID + ">");
				
				application.adminManager.userIgnores[y][z] = null;
				delete application.adminManager.userIgnores[y][z];
				
			}
		}
	}
	
	for (y in application.adminManager.userIgnores)
	{
		var hasChildren = 0;
		for (z in application.adminManager.userIgnores[y])
		{
			hasChildren = 1;
			
			break;
		}
		
		if (!hasChildren)
		{
			trace("AdminManager.fixBlocks->  <DELETING>  this: " + this + "  hasChildren:" + hasChildren + "  <y:" + y + ":" + this.userIgnores[y] + ">  <z:" + z + ":" + this.userIgnores[y][z] + ">");
			
			application.adminManager.userIgnores[y] = null;
			delete application.adminManager.userIgnores[y];
		}
	}
	*/
	// TODO:
	// save to the userIgnores Object and SharedObject
	if (hasChanged)
	{
		this.saveBlockedUsers();
	}
	
	/*
	function fixBlock(targetAcctID)
	{
		
		targetAcctID = null;
	}
	*/
	
	z = null;
	y = null;
	i = null;
	numChildren = null;
	hasChanged = null;
	tmpBlockedUsersList = null;
	adminObj = null;
	targetAcctID = null;
	clientID = null;
}


AdminManager.prototype.ignoreUser = function(msgObj)
{
	if (msgObj.selectedUserID)
	{
		var ignoreInfo = new Object();
		ignoreInfo.ignoreDate = new Date().toString();
		ignoreInfo.whoIgnoredID = msgObj.userID;
		ignoreInfo.whoIgnoredName = application.userManager.users["user_"+msgObj.userID].nonDuplicateName;
		ignoreInfo.whoIgnoredAcctID = application.userManager.users["user_"+msgObj.userID].acctID;
		ignoreInfo.ignoredWhoID = msgObj.selectedUserID;
		ignoreInfo.ignoredWhoName = application.userManager.users["user_"+msgObj.selectedUserID].nonDuplicateName;
		ignoreInfo.ignoredWhoAcctID = application.userManager.users["user_"+msgObj.selectedUserID].acctID;
		
		var isAGuestIgnoring = (ignoreInfo.whoIgnoredAcctID == 0);
		var isIgnoringAGuest = (ignoreInfo.ignoredWhoAcctID == 0);
		var firstNodeName = (isAGuestIgnoring ? "guest_" + ignoreInfo.whoIgnoredID : "member_" + ignoreInfo.whoIgnoredAcctID);
		var secondNodeName = (isIgnoringAGuest ? "guest_" + ignoreInfo.ignoredWhoName : "member_" + ignoreInfo.ignoredWhoAcctID);
		
		trace("AdminManager.ignoreUser->  isAGuestIgnoring: " + isAGuestIgnoring + "  isIgnoringAGuest: " + isIgnoringAGuest + "  firstNodeName: " + firstNodeName + "  secondNodeName: " + secondNodeName);
		
		if (!this.userIgnores[firstNodeName])
			this.userIgnores[firstNodeName] = new Object();
		
		this.userIgnores[firstNodeName][secondNodeName] = ignoreInfo;
		
		// tell the ignoring client they have successfully ignored a user
		//if (application.userManager.users["user_" + ignoreInfo.whoIgnoredID])
		//	application.userManager.users["user_" + ignoreInfo.whoIgnoredID].call("ignoredUser", null, ignoreInfo);
		
		// tell the target client they have been ignored
		//if (application.userManager.users["user_" + ignoreInfo.ignoredWhoID])
		//	application.userManager.users["user_" + ignoreInfo.ignoredWhoID].call("ignoredUser", null, ignoreInfo);
		
		for (var i in application.userManager.users)
		{
			// tell the ignoring client they have successfully ignored a user
			if (((isAGuestIgnoring) && 
				(application.userManager.users[i].userID == ignoreInfo.whoIgnoredID)) || 
				((!isAGuestIgnoring) && 
				(application.userManager.users[i].acctID == ignoreInfo.whoIgnoredAcctID)))
			{
				application.userManager.users[i].call("ignoredUser", null, ignoreInfo);
			}
			
			// tell the target client they have been ignored
			if (((isIgnoringAGuest) && 
				(application.userManager.users[i].nonDuplicateName == ignoreInfo.ignoredWhoName)) || 
				((!isIgnoringAGuest) && 
				(application.userManager.users[i].acctID == ignoreInfo.ignoredWhoAcctID)))
			{
				application.userManager.users[i].call("ignoredUser", null, ignoreInfo);
			}
			
			i = null;
		}
		
		/*
		// TODO:
		// switch from userName to acctID/userID
		if (ignoreInfo.whoIgnoredAcctID == 0)
		{
			// a guest is ignoring someone,
			// create an Object named guest_userID,
			// which will be deleted when the user disconnects
			if (!this.userIgnores["guest_"+ignoreInfo.whoIgnoredID])
			{
				this.userIgnores["guest_"+ignoreInfo.whoIgnoredID] = new Object();
			}
			
			// create a sub-Object named guest_/member_ + ignoreInfo.ignoredWhoName/AcctID
			this.userIgnores["guest_"+ignoreInfo.whoIgnoredID][(isIgnoringAGuest ? "guest_" + ignoreInfo.ignoredWhoName : "member_" + ignoreInfo.ignoredWhoAcctID)] = ignoreInfo;
		} else {
			// a registered user is ignoring someone,
			// create an Object named guest_/member_ + ignoreInfo.ignoredWhoAcctID
			if (!this.userIgnores["member_"+ignoreInfo.whoIgnoredAcctID])
			{
				this.userIgnores["member_"+ignoreInfo.whoIgnoredAcctID] = new Object();
			}
			
			// create a sub-Object named guest_/member_ + ignoreInfo.ignoredWhoName/AcctID
			this.userIgnores["member_"+ignoreInfo.whoIgnoredAcctID][(isIgnoringAGuest ? "guest_" + ignoreInfo.ignoredWhoName : "member_" + ignoreInfo.ignoredWhoAcctID)] = ignoreInfo;
		}
		*/
		
		this.saveBlockedUsers();
		
		//trace("AdminManager.ignoreUser->  <isUserIgnored>  ignoredWhoName: "+ignoredWhoName+"  ignoredWhoAcctID: "+ignoredWhoAcctID+"  =  "+this.isUserIgnored(ignoreInfo.whoIgnoredName, ignoreInfo.whoIgnoredAcctID));
	} else {
		//trace("########## NO USER SELECTED TO IGNORE! #############");
	}
	
	secondNodeName = null;
	firstNodeName = null;
	isUnignoringAGuest = null;
	isAGuestUnignoring = null;
	ignoreInfo = null;
	msgObj = null;
}


AdminManager.prototype.unignoreUser = function(cmdObj)
{
	if (!cmdObj.ignoreInfo)
		return;
	
	var ignoreInfo = cmdObj.ignoreInfo;
	var isAGuestUnignoring = (ignoreInfo.whoIgnoredAcctID == 0);
	var isUnignoringAGuest = (ignoreInfo.ignoredWhoAcctID == 0);
	var firstNodeName = (isAGuestUnignoring ? "guest_" + ignoreInfo.whoIgnoredID : "member_" + ignoreInfo.whoIgnoredAcctID);
	var secondNodeName = (isUnignoringAGuest ? "guest_" + ignoreInfo.ignoredWhoName : "member_" + ignoreInfo.ignoredWhoAcctID);
	
	//var isAGuestUnignoring = (application.userManager.users["user_" + cmdObj.userID].acctID == 0);
	//var isUnignoringAGuest = (application.userManager.users["user_" + cmdObj.selectedUserID].acctID == 0);
	//var firstNodeName = (isAGuestUnignoring ? "guest_" + cmdObj.userID : "member_" + application.userManager.users["user_" + cmdObj.userID].acctID);
	//var secondNodeName = (isUnignoringAGuest ? "guest_" + application.userManager.users["user_" + cmdObj.selectedUserID].userName : "member_" + application.userManager.users["user_" + cmdObj.selectedUserID].acctID);
	
	//trace("AdminManager.isUserIgnored->  "+this.isUserIgnored(application.userManager.users["user_"+cmdObj.userID].userName,application.userManager.users["user_"+cmdObj.userID].acctID,application.userManager.users["user_"+cmdObj.selectedUserID].userName));
	trace("AdminManager.unignoreUser->  isAGuestUnignoring: " + isAGuestUnignoring + "  isUnignoringAGuest: " + isUnignoringAGuest + "  firstNodeName: " + firstNodeName + "  secondNodeName: " + secondNodeName);
	
	for (var i in application.userManager.users)
	{
		// tell the ignoring client they have successfully ignored a user
		if (((isAGuestUnignoring) && 
			(application.userManager.users[i].userID == ignoreInfo.whoIgnoredID)) || 
			((!isAGuestUnignoring) && 
			(application.userManager.users[i].acctID == ignoreInfo.whoIgnoredAcctID)))
		{
			trace("AdminManager.unignoreUser->  <CALLING>  whoIgnoredName: " + application.userManager.users[i].nonDuplicateName + "  cmd: unignoreUser");
			application.userManager.users[i].call("unignoredUser", null, ignoreInfo);
		}
		
		// tell the target client they have been ignored
		if (((isUnignoringAGuest) && 
			(application.userManager.users[i].nonDuplicateName == ignoreInfo.ignoredWhoName)) || 
			((!isUnignoringAGuest) && 
			(application.userManager.users[i].acctID == ignoreInfo.ignoredWhoAcctID)))
		{
			trace("AdminManager.unignoreUser->  <CALLING>  ignoredWhoName: " + application.userManager.users[i].nonDuplicateName + "  cmd: unignoreUser");
			application.userManager.users[i].call("unignoredUser", null, ignoreInfo);
		}
		
		i = null;
	}
	
	// tell the ignoring client they have successfully unignored a user
	//if (application.userManager.users["user_" + ignoreInfo.whoIgnoredID])
	//	application.userManager.users["user_" + ignoreInfo.whoIgnoredID].call("unignoredUser", null, ignoreInfo);
	// tell the target client they have been unignored
	//if ((isUnignoringAGuest) && (application.userManager.getClientFromAcctID(ignoreInfo.ignoredWhoAcctID)))
	//	application.userManager.getClientFromAcctID(ignoreInfo.ignoredWhoAcctID).call("unignoredUser", null, ignoreInfo);
	
	this.userIgnores[firstNodeName][secondNodeName] = null;
	delete this.userIgnores[firstNodeName][secondNodeName];
	
	// clear empty objects
	var numChildren = 0;
	for (var o in this.userIgnores[firstNodeName])
	{
		++numChildren;
	}
	if (numChildren==0)
	{
		this.userIgnores[firstNodeName] = null;
		delete this.userIgnores[firstNodeName];
	}
	
	this.saveBlockedUsers();
	
	/*
	if (application.userManager.users["user_"+cmdObj.userID].acctID == 0)
	{
		//a guest is unignoring someone
		if (this.userIgnores["guest_"+cmdObj.userID][() + cmdObj.selectedUserID])
		{
			application.userManager.users["user_" + cmdObj.selectedUserID].call("unignoredUser", null, this.userIgnores["guest_"+application.userManager.users["user_"+cmdObj.userID].userName][application.userManager.users["user_"+cmdObj.selectedUserID].userName]);
			
			this.userIgnores["guest_"+application.userManager.users["user_"+cmdObj.userID].userName][application.userManager.users["user_"+cmdObj.selectedUserID].userName] = null;
			delete this.userIgnores["guest_"+application.userManager.users["user_"+cmdObj.userID].userName][application.userManager.users["user_"+cmdObj.selectedUserID].userName];
			
			for (var i in this.userIgnores["guest_"+application.userManager.users["user_"+cmdObj.userID].userName])
			{}
			
			if (!i)
			{
				this.userIgnores["guest_"+application.userManager.users["user_"+cmdObj.userID].userName] = null;
				delete this.userIgnores["guest_"+application.userManager.users["user_"+cmdObj.userID].userName];
			}
			
			i = null;
		}
	} else {
		//a registered user is unignoring someone
		if (this.userIgnores["member_"+application.userManager.users["user_"+cmdObj.userID].acctID][application.userManager.users["user_"+cmdObj.selectedUserID].userName])
		{
			application.userManager.users["user_" + cmdObj.selectedUserID].call("unignoredUser", null, this.userIgnores["member_"+application.userManager.users["user_"+cmdObj.userID].acctID][application.userManager.users["user_"+cmdObj.selectedUserID].userName]);
		}
		
		this.userIgnores["member_"+application.userManager.users["user_"+cmdObj.userID].acctID][application.userManager.users["user_"+cmdObj.selectedUserID].userName] = null;
		delete this.userIgnores["member_"+application.userManager.users["user_"+cmdObj.userID].acctID][application.userManager.users["user_"+cmdObj.selectedUserID].userName];
		
		for (var i in this.userIgnores["member_"+application.userManager.users["user_"+cmdObj.userID].acctID])
		{}
		
		if (!i)
		{
			this.userIgnores["member_"+application.userManager.users["user_"+cmdObj.userID].acctID] = null;
			delete this.userIgnores["member_"+application.userManager.users["user_"+cmdObj.userID].acctID];
		}
		
		i = null;
	}
	*/
	
	secondNodeName = null;
	firstNodeName = null;
	isUnignoringAGuest = null;
	isAGuestUnignoring = null;
	ignoreInfo = null;
	cmdObj = null;
}


// TODO:
// fix
/*
AdminManager.prototype.isUserIgnored = function(whoIgnoredName, whoIgnoredAcctID, ignoredWhoName)
{
	var isIgnored = false;
	for (var i in application.userManager.users)
	{
		if (((application.userManager.users[i].acctID == 0) && 
			(application.userManager.users[i].userName == whoIgnoredName)) || 
			((application.userManager.users[i].acctID != 0) && 
			(application.userManager.users[i].acctID == whoIgnoredAcctID)))
		{
			if (application.userManager.users[i].acctID == 0)
			{
				if (this.userIgnores["guest_"+application.userManager.users[i].userName][ignoredWhoName])
				{
					isIgnored = true;
				}
			} else {
				if (this.userIgnores["member_"+application.userManager.users[i].acctID][ignoredWhoName])
				{
					isIgnored = true;
				}
			}
		}
	}
	
	//trace("########## isUserIgnored.isIgnored #############>  isIgnored: "+isIgnored+"  ");
	
	i = null;
	whoIgnoredName = null;
	whoIgnoredAcctID = null;
	ignoredWhoName = null;
	
	return isIgnored;
}
*/

AdminManager.prototype.isUserBanned = function(ip)
{
	var banObj = null;
	var ipArr = ip.split(".");
	
	if (this.bannedUsers["BAN_"+ip])
	{
		banObj = this.bannedUsers["BAN_"+ip];
	} else if (this.bannedUsers["BANNEDIP_"+ipArr[0]+".0.0.0"]) {
		banObj = this.bannedUsers["BANNEDIP_"+ipArr[0]+".0.0.0"];
	} else if (this.bannedUsers["BANNEDIP_"+ipArr[0]+"."+ipArr[1]+".0.0"]) {
		banObj = this.bannedUsers["BANNEDIP_"+ipArr[0]+"."+ipArr[1]+".0.0"];
	} else if (this.bannedUsers["BANNEDIP_"+ipArr[0]+"."+ipArr[1]+"."+ipArr[2]+".0"]) {
		banObj = this.bannedUsers["BANNEDIP_"+ipArr[0]+"."+ipArr[1]+"."+ipArr[2]+".0"];
	} else if (this.bannedUsers["BANNEDIP_"+ipArr[0]+"."+ipArr[1]+"."+ipArr[2]+"."+ipArr[3]]) {
		banObj = this.bannedUsers["BANNEDIP_"+ipArr[0]+"."+ipArr[1]+"."+ipArr[2]+"."+ipArr[3]];
	}
	
	//trace("isUserBanned>  ip: "+ip+"  ipArr: "+ipArr+"  ipArr.length: "+ip.length+"  banObj: "+banObj);
	
	ipArr = null;
	ip = null;
	
	return banObj;
}


AdminManager.prototype.addBot = function(adminClientID, botNamePrefix)
{
	var adminObj = application.userManager.getClientFromClientID(adminClientID);
	
	trace("AdminManager.addBot->\n\t\t\tadminClientID: "+adminClientID+"\n\t\t\tbotNamePrefix: "+botNamePrefix+"\n\t\t\tadminObj: "+adminObj+"\n\t\t\tadminObj.adminType: "+adminObj.adminType);
	
	if ((!adminObj) ||
		(adminObj.adminType != "sa") &&
		(adminObj.adminType != "ga"))
		return;
	
	// TODO make 'load .asc' global, to show code errors when the application loads
	var botID = this.testBots_Arr.length;
	this.bots["bot_"+botID] = new TestBot(botID, botNamePrefix, adminObj.acctID);
	this.testBots_Arr.push(this.bots["bot_"+botID]);
	
	var msgObj = new Object();
	msgObj.msg = "Adding bot with prefix: "+botNamePrefix;
	msgObj.msg += "\n\t\t\tbotID: "+botID;
	
	adminObj.call("showAdminMessage", null, msgObj);
	
	trace("AdminManager.addBot-> botID: "+botID);
	
	botID = null;
	msgObj = null;
	adminObj = null;
	botNamePrefix = null;
	adminClientID = null;
}


AdminManager.prototype.delBot = function(adminClientID, botUserID)
{
	var adminObj = application.userManager.getClientFromClientID(adminClientID);
	
	trace("AdminManager.delBot->\n\t\t\tadminClientID: "+adminClientID+"\n\t\t\tbotUserID: "+botUserID+"\n\t\t\tadminObj: "+adminObj+"\n\t\t\tadminObj.adminType: "+adminObj.adminType);
	
	if ((!adminObj) ||
		(adminObj.adminType != "sa") &&
		(adminObj.adminType != "ga"))
		return;
	
	var msgObj = new Object();
	var botObj = application.userManager.users["user_"+botUserID];
	
	if (botObj)
	{
		msgObj.msg = "Deleting bot with userID: "+botUserID;
		// TODO
	} else {
		msgObj.msg = "WARNING! No such bot with userID: "+botUserID;
	}
	
	adminObj.call("showAdminMessage", null, msgObj);
	
	botObj = null;
	msgObj = null;
	adminObj = null;
	botNamePrefix = null;
	adminClientID = null;
}



// send the user the current/minimum server version
function sendClientServerVersion(clientID)
{
	if (!clientID) return;
	
	var clientObj = application.userManager.getClientFromClientID(clientID);
	
	if (!clientObj) return;
	
	var soPropName = clientObj.version.toString().charAt(0) == '3' ? 'version' : 'beta';
	var msgObj = new Object();
	msgObj.msg = "Current minimum" + (soPropName == 'beta' ? ' BETA' : '') +" version:  "+application.userManager.versionSO.getProperty(soPropName)+"\n";
	msgObj.msg += "* Admin:  Your current version:  "+clientObj.version;
	
	clientObj.call("showAdminMessage", null, msgObj);
	
	msgObj = null;
	soPropName = null;
	clientObj = null;
	clientID = null;
}


// get a clients Client object via their client.id
//function getClientFromClientID(clientID, matchLastHalfOnly) /* returns a Client object */
//{
//	return application.userManager.getClientFromClientID(clientID, matchLastHalfOnly);
//}




function kickOutUser(client)
{
	clearInterval(client.kickInterval);
	
	application.disconnect(client);
	
	client = null;
}



//function to format HTML from the message
function parseOutHTML(str)
{
	//get rid of all brackets that a user might have put in
	do{
		str = str.replace(/</, "&lt;");
	}
	while(str.indexOf("<") != -1);
	
	do{
		str = str.replace(/>/, "&gt;");
	}
	while(str.indexOf(">") != -1);
	
	// block &#xa;
	do{
		str = str.replace("&#","");
	}
	while(str.indexOf("&#") != -1);
	
	str = str.replace(/(https:\/\/|http:\/\/|www\.)\S*\.\S*\b/gi, parseURL);
	
	return str;
}



function shutdownAppTimerFunction(adminName, isRestart, warnMsg)
{
	//trace('|###| AdminManager.shutdownAppTimerFunction |###|>  adminName: '+adminName+'  isRestart: '+isRestart+'  shutdownTimerCount: '+application.adminManager.shutdownTimerCount);
	
	application.adminManager.shutdownTimerCount++;
	application.adminManager.shutdownWaitTimeSeconds--;
	
	if ((!warnMsg) || (!warnMsg.length))
		warnMsg = "No reason given.";
	
	if (!isRestart)
		isRestart = false;
	
	if (!adminName)
		adminName = "SERVER";
	
	// if this is the first timer interval
	if (application.adminManager.shutdownTimerCount == 1)
	{
		trace('|###| AdminManager.shutdownAppTimerFunction |###|>  adminName: '+adminName+'  isRestart: '+isRestart+'  shutdownTimerCount: '+application.adminManager.shutdownTimerCount+'  shutdownWaitTimeSeconds: '+application.adminManager.shutdownWaitTimeSeconds+'  warnMsg: '+warnMsg);
	}
	
	//shutdown/restart the instance
	if (application.adminManager.shutdownWaitTimeSeconds <= 0) {
		trace('|###| AdminManager.shutdownAppTimerFunction |###|>  SHUTTING DOWN NOW!');
		clearInterval(application.adminManager.timerInterval);
		
		application.adminManager.timerInterval = null;
		
		//use the admin API to shutdown
		application.shutdown();
	} else if (application.adminManager.shutdownWaitTimeSeconds > 0) {
		trace('|###| AdminManager.shutdownAppTimerFunction |###|>  shutdownTimerCount: '+application.adminManager.shutdownTimerCount+'  shutdownWaitTimeSeconds: '+application.adminManager.shutdownWaitTimeSeconds+'  SHUTTING DOWN IN: '+application.adminManager.shutdownWaitTimeSeconds+'s');
		
		sendShutdownWarningMessage(adminName, warnMsg, application.adminManager.shutdownWaitTimeSeconds);
	}
}



function sendShutdownWarningMessage(adminName, warnMsg, timeLeft)
{
	var timeLeft_Str = timeLeft.toString();
	
	//trace('|###| AdminManager.sendShutdownWarningMessage |###|>  adminName: '+adminName+'  warnMsg: '+warnMsg+'  timeLeft: '+timeLeft+'  timeLeft_Str: '+timeLeft_Str+'  timeLeft_Str.length: '+timeLeft_Str.length+'  timeLeft_Str.charAt(): '+timeLeft_Str.charAt(timeLeft_Str.length -1));
	
	if ((application.adminManager.shutdownTimerCount == 1) || 
		(timeLeft_Str.charAt(timeLeft_Str.length-1) == "0") || 
		//(timeLeft_Str.charAt(timeLeft_Str.length-1) == "5") || 
		(timeLeft < 10))
	{
		trace('|###| AdminManager.sendShutdownWarningMessage |###|>  adminName: '+adminName+'  warnMsg: '+warnMsg+'  timeLeft: '+timeLeft);
		
		var msgObj = new Object();
		msgObj.msg = "WARNING: Server reboot in: "+timeLeft+"s.  Reason: <"+adminName+"> "+warnMsg;
		
		application.broadcastMsg("showAdminMessage", msgObj);
	}
}





function shutdownApp()
{
	trace('|###| AdminManager.shutdownApp |###|>  SHUTTING DOWN NOW!');
	
	clearInterval(application.adminManager.timerInterval);
	
	application.adminManager.timerInterval = null;
	
	//use the admin API to shutdown
	application.shutdown();
}



























